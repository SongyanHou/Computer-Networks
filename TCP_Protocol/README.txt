README FILE FOR PROGRAMMING ASSIGNMENT 2
Author: Songyan Hou (sh3348)

========================================================================================
For this project, I take a stop-and-wait mechanism to simulate the TCP-like transportation. The window size is always 1. Each time the sender sends a packet, it has to wait for the ACK signal indicating a successful transmission to continue passing the next packet to the receiver.

As for the header design, I follow the basic structure mentioned in the textbook. The header size is 20 bytes and the MSS is 576 bytes. However for simplicity, I choose to set the sequence number starting from 0 and incremented by 1 each time it moves forward. The range of sequence number is from 0 to the number of the packets of this file. And for the ACK transmission part, I use TCP to transmit a integer indicating the sequence number of a right transmitted packet back. For instance, if packet N is successfully received, the receiver will send number N back to sender telling that the sender could send packet N+1 next.

Since the integer number sent from receiver through TCP channel has already realize the function of ACK number and ACK bit. ACK number field in the header is actually of no use in this design, therefore I set this field 0 and ACK bit 1. 

If it comes to final packet, the FIN flag will be set. After confirming the FIN and right packet, the receiver will also send a finishing signal back to terminate the transmission process. 

When using the proxy, the destination port number of the sender part is the port number of proxy. They are displayed in the log file. Besides, the source port number of received ACK packets recorded in the sender's log file is actually the port number of receiver side TCP socket. It is randomly generated by OS. So each time you run this program, you could see different source port number for ACK packets. As for the flags part in the log file, I took the decimal form of the byte field in header containing all flags as the result. 16 means FIN is not set(0x10), and 17 means FIN is set(0x11).

As for the timeout value calculation, I followed the standard in the textbook. The initial value is 1 second. Timeout=Estimated RTT + 4 * |DevRTT|. When timeout occurs, the value will be doubled.

All the relative files (including log files) will be created in the local folder. So please do no use the same file name when invoking these two programs. Of course if the sender.java and receiver.java exist in different folders. It will not cause any problems. If the folder has already got the file with duplicated name, the program will rewrite this file or the file would not be created.
=========================================================================================
./newudpl -o localhost:20000 -i localhost:20001 -p4000:6000 -L 30 -B 10 -d 0.05
%java receiver rfile.txt 20000 127.0.0.1 20001 logfile.txt
%java sender file.txt 127.0.0.1 4000 20001 slogfile.txt

send file: file.txt; receive file: rfile.txt
sender's log file: slogfile.txt
receiver's log file: logfile.txt
sender's listening port (TCP) and sending port (UDP) 20001; destination port 4000 (proxy)
receiver's listening port (UDP) 20000, send ACKs to port 20001 on 127.0.0.1
=========================================================================================
When testing on my local machine, I found that if the bit error rate is large(for example: 50 or more), the transmission might get stuck because there could be continuous packet corruption and each time a packet gets corrupted, the timeout value will double, influencing the transmission performance severely. I am not sure why there will always be continuous packet error in my test. However, it will not cause the transmission failure, just take longer time. That is a flaw of my design, which I will figure it out in the future.

Besides, during the test, I also found that the corruption always happens in the header field (source port number). I am not sure if it was because the error generating methods of the proxy. Since all packets are logged in the log file. You might see different source port number in the log file. That is the consequence of the header corruption.
=========================================================================================
I built up the whole program on Mac OS 10.9.4. 
The tool I use is Eclipse(Android Developer Tools). 
Tests are made on terminals.
Java version "1.6.0_65"
Java(TM) SE Runtime Environment (build 1.6.0_65-b14-466.1-11M4716)
Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-466.1, mixed mode)
